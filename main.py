def quick_sort(arr):
    if len(arr) <= 1:
        return arr  # Базовый случай: массив из одного элемента или пустой уже отсортирован
    else:
        # Выбираем опорный элемент (pivot)
        pivot = arr[len(arr) // 2]
        # Разделяем массив на три части: меньше опорного, равные опорному и больше опорного
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        # Рекурсивно сортируем левую и правую части и объединяем результат
        return quick_sort(left) + middle + quick_sort(right)

# Пример использования:
arr = [64, 25, 12, 22, 11]
print("Исходный массив:", arr)
print("Отсортированный массив (Quick Sort):", quick_sort(arr))

#1. Оценка временной сложности
#▎Общий принцип работы алгоритма
#• Алгоритм делит массив на три части:
#  • left: элементы меньше опорного элемента (pivot).
#  • middle: элементы, равные опорному элементу.
#  • right: элементы больше опорного элемента.
#• Затем рекурсивно сортируются подмассивы left и right.
#• Итоговый результат объединяется: quick_sort(left) + middle + quick_sort(right).

#▎Сложность разбиения массива
#Для каждой итерации мы выполняем операции, чтобы разделить массив на три части:
#left = [x for x in arr if x < pivot]
#middle = [x for x in arr if x == pivot]
#right = [x for x in arr if x > pivot]
#Эти операции требуют прохода по всему массиву, то есть имеют сложность O(n), где n — длина массива.

#▎Рекурсивные вызовы
#После разбиения массива алгоритм вызывает себя рекурсивно для подмассивов left и right.
# Если массив делится на две примерно равные части на каждой итерации (в среднем случае),
# глубина рекурсии будет порядка log(n). Таким образом, общее количество операций составит:
#T(n) = n + 2 ⋅ T((n / 2))
#Решая это уравнение (методом подстановки или с использованием теоремы мастера), получаем:
#T(n) = O(n ⋅ log(n))

#▎Худший случай
#В худшем случае массив делится неравномерно, например, если опорный элемент оказывается минимальным или
# максимальным в массиве. Тогда один из подмассивов будет содержать все элементы, кроме одного.
# Глубина рекурсии в этом случае будет порядка n, а сложность составит:
#T(n) = n + T(n-1)
#Это развернется в арифметическую прогрессию:
#T(n) = n + (n-1) + (n-2) + … + 1 = n ⋅ (n+1) / 2 = O(n²)
#Таким образом, в худшем случае временная сложность алгоритма — O(n²).
#▎Лучший случай
#Если массив делится идеально на две равные части на каждой итерации, сложность составит O(n \cdot log(n)).


#▎2. Оценка пространственной сложности
#Алгоритм использует дополнительную память для хранения подмассивов left, middle и right на каждой итерации.
# Для каждого уровня рекурсии создаются новые массивы.
#• В среднем случае глубина рекурсии составляет O(log(n)), но на каждом уровне создаются новые массивы,
# суммарный размер которых равен длине исходного массива.
#• В худшем случае глубина рекурсии составит O(n), а суммарный объем дополнительной памяти также будет порядка O(n).
#Итак, пространственная сложность:
#• Средний случай: O(n).
#• Худший случай: O(n).


#▎Итоговая оценка

#| Случай              | Временная сложность | Пространственная сложность |
#|---------------------|---------------------|----------------------------|
#| Лучший случай       | O(n log n)         | O(n)                       |
#| Средний случай      | O(n log n)         | O(n)                       |
#| Худший случай       | O(n²)              | O(n)                       |

#▎Вывод
#Этот алгоритм быстрой сортировки (Quick Sort):
#• Эффективен в среднем и лучшем случаях с временной сложностью O(n log n).
#• Однако в худшем случае его временная сложность возрастает до O(n²), что можно исправить выбором случайного
# опорного элемента (randomized qui